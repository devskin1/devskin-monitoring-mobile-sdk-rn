"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;
var _kleur = _interopRequireDefault(require("kleur"));
var _path = _interopRequireDefault(require("path"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _which = _interopRequireDefault(require("which"));
var _crossSpawn = _interopRequireDefault(require("cross-spawn"));
var _del = _interopRequireDefault(require("del"));
var _json = _interopRequireDefault(require("json5"));
var _os = require("os");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function build({
  source,
  root,
  output,
  report,
  options
}) {
  report.info(`Cleaning up previous build at ${_kleur.default.blue(_path.default.relative(root, output))}`);
  await (0, _del.default)([output]);
  report.info(`Generating type definitions with ${_kleur.default.blue('tsc')}`);
  const project = options?.project ? options.project : 'tsconfig.json';
  const tsconfig = _path.default.join(root, project);
  try {
    if (await _fsExtra.default.pathExists(tsconfig)) {
      try {
        const config = _json.default.parse(await _fsExtra.default.readFile(tsconfig, 'utf-8'));
        if (config.compilerOptions) {
          const conflicts = [];
          if (config.compilerOptions.noEmit !== undefined) {
            conflicts.push('compilerOptions.noEmit');
          }
          if (config.compilerOptions.emitDeclarationOnly !== undefined) {
            conflicts.push('compilerOptions.emitDeclarationOnly');
          }
          if (config.compilerOptions.declarationDir) {
            conflicts.push('compilerOptions.declarationDir');
          }
          if (config.compilerOptions.outDir && _path.default.join(root, config.compilerOptions.outDir) !== output) {
            conflicts.push('compilerOptions.outDir');
          }
          if (conflicts.length) {
            report.warn(`Found following options in the config file which can conflict with the CLI options. Please remove them from ${_kleur.default.blue(project)}:${conflicts.reduce((acc, curr) => acc + `\n${_kleur.default.gray('-')} ${_kleur.default.yellow(curr)}`, '')}`);
          }
        }
      } catch (e) {
        report.warn(`Couldn't parse '${project}'. There might be validation errors.`);
      }
    } else {
      throw new Error(`Couldn't find a ${_kleur.default.blue('tsconfig.json')} in the project root.`);
    }
    let tsc;
    if (options?.tsc) {
      tsc = _path.default.resolve(root, options.tsc);
      if (!(await _fsExtra.default.pathExists(tsc))) {
        throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed at ${_kleur.default.blue(tsc)}. Please specify the correct path in options or remove it to use the workspace's version.`);
      }
    } else {
      const execpath = process.env.npm_execpath;
      const cli = execpath?.split('/').pop()?.includes('yarn') ? 'yarn' : 'npm';
      if (cli === 'yarn') {
        const result = _crossSpawn.default.sync('yarn', ['bin', 'tsc'], {
          stdio: 'pipe',
          encoding: 'utf-8',
          cwd: root
        });
        tsc = result.stdout.trim();
      } else {
        tsc = _path.default.resolve(root, 'node_modules', '.bin', 'tsc');
      }
      if ((0, _os.platform)() === 'win32' && !tsc.endsWith('.cmd')) {
        tsc += '.cmd';
      }
    }
    if (!(await _fsExtra.default.pathExists(tsc))) {
      try {
        tsc = await (0, _which.default)('tsc');
        if (await _fsExtra.default.pathExists(tsc)) {
          report.warn(`Failed to locate ${_kleur.default.blue('tsc')} in the workspace. Falling back to the binary found in ${_kleur.default.blue('PATH')} at ${_kleur.default.blue(tsc)}. Consider adding ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specifying the ${_kleur.default.blue('tsc')} option for the typescript target.`);
        }
      } catch (e) {
        // Ignore
      }
    }
    if (tsc == null || !(await _fsExtra.default.pathExists(tsc))) {
      throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed under ${_kleur.default.blue('node_modules')} or present in $PATH. Make sure you have added ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specify the ${_kleur.default.blue('tsc')} option for typescript.`);
    }
    const tsbuildinfo = _path.default.join(output, project.replace(/\.json$/, '.tsbuildinfo'));
    try {
      await (0, _del.default)([tsbuildinfo]);
    } catch (e) {
      // Ignore
    }
    const result = _crossSpawn.default.sync(tsc, ['--pretty', '--declaration', '--declarationMap', '--emitDeclarationOnly', '--project', project, '--outDir', output], {
      stdio: 'inherit',
      cwd: root
    });
    if (result.status === 0) {
      await (0, _del.default)([tsbuildinfo]);
      report.success(`Wrote definition files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
      const pkg = JSON.parse(await _fsExtra.default.readFile(_path.default.join(root, 'package.json'), 'utf-8'));
      const getGeneratedTypesPath = async () => {
        if (pkg.source) {
          const indexDTsName = _path.default.basename(pkg.source).replace(/\.(jsx?|tsx?)$/, '') + '.d.ts';
          const potentialPaths = [_path.default.join(output, _path.default.dirname(pkg.source), indexDTsName), _path.default.join(output, _path.default.dirname(_path.default.relative(source, _path.default.join(root, pkg.source))), indexDTsName)];
          for (const potentialPath of potentialPaths) {
            if (await _fsExtra.default.pathExists(potentialPath)) {
              return _path.default.relative(root, potentialPath);
            }
          }
        }
        return null;
      };
      if ('types' in pkg) {
        const typesPath = _path.default.join(root, pkg.types);
        if (!(await _fsExtra.default.pathExists(typesPath))) {
          const generatedTypesPath = await getGeneratedTypesPath();
          if (!generatedTypesPath) {
            report.warn(`Failed to detect the entry point for the generated types. Make sure you have a valid ${_kleur.default.blue('source')} field in your ${_kleur.default.blue('package.json')}.`);
          }
          report.error(`The ${_kleur.default.blue('types')} field in ${_kleur.default.blue('package.json')} points to a non-existent file: ${_kleur.default.blue(pkg.types)}.\nVerify the path points to the correct file under ${_kleur.default.blue(_path.default.relative(root, output))}${generatedTypesPath ? ` (found ${_kleur.default.blue(generatedTypesPath)}).` : '.'}`);
          throw new Error("Found incorrect path in 'types' field.");
        }
      } else {
        const generatedTypesPath = await getGeneratedTypesPath();
        report.warn(`No ${_kleur.default.blue('types')} field found in ${_kleur.default.blue('package.json')}.\nConsider ${generatedTypesPath ? `pointing it to ${_kleur.default.blue(generatedTypesPath)}` : 'adding it'} so that consumers of your package can use the types.`);
      }
    } else {
      throw new Error('Failed to build definition files.');
    }
  } catch (e) {
    if (e != null && typeof e === 'object') {
      if ('stdout' in e && e.stdout != null) {
        report.error(`Errors found when building definition files:\n${e.stdout.toString()}`);
      } else if ('message' in e && typeof e.message === 'string') {
        report.error(e.message);
      } else {
        throw e;
      }
    } else {
      throw e;
    }
    throw new Error('Failed to build definition files.');
  }
}
//# sourceMappingURL=typescript.js.map