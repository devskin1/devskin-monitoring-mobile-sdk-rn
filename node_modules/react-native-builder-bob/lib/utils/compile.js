"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compile;
var _path = _interopRequireDefault(require("path"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _kleur = _interopRequireDefault(require("kleur"));
var babel = _interopRequireWildcard(require("@babel/core"));
var _browserslist = _interopRequireDefault(require("browserslist"));
var _glob = _interopRequireDefault(require("glob"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function compile({
  root,
  source,
  output,
  babelrc = false,
  configFile = false,
  exclude,
  modules,
  copyFlow,
  sourceMaps = true,
  report,
  field
}) {
  const files = _glob.default.sync('**/*', {
    cwd: source,
    absolute: true,
    nodir: true,
    ignore: exclude
  });
  report.info(`Compiling ${_kleur.default.blue(String(files.length))} files in ${_kleur.default.blue(_path.default.relative(root, source))} with ${_kleur.default.blue('babel')}`);
  const pkg = JSON.parse(await _fsExtra.default.readFile(_path.default.join(root, 'package.json'), 'utf-8'));
  if (copyFlow) {
    if (!Object.keys(pkg.devDependencies || {}).includes('flow-bin')) {
      report.warn(`The ${_kleur.default.blue('copyFlow')} option was specified, but couldn't find ${_kleur.default.blue('flow-bin')} in ${_kleur.default.blue('package.json')}.\nIf the project is using ${_kleur.default.blue('flow')}, then make sure you have added ${_kleur.default.blue('flow-bin')} to your ${_kleur.default.blue('devDependencies')}, otherwise remove the ${_kleur.default.blue('copyFlow')} option.`);
    }
  }
  await Promise.all(files.map(async filepath => {
    const outputFilename = _path.default.join(output, _path.default.relative(source, filepath)).replace(/\.(jsx?|tsx?)$/, '.js');
    await _fsExtra.default.mkdirp(_path.default.dirname(outputFilename));
    if (!/\.(jsx?|tsx?)$/.test(filepath)) {
      // Copy files which aren't source code
      _fsExtra.default.copy(filepath, outputFilename);
      return;
    }
    const content = await _fsExtra.default.readFile(filepath, 'utf-8');
    const result = await babel.transformAsync(content, {
      cwd: root,
      babelrc: babelrc,
      configFile: configFile,
      sourceMaps,
      sourceRoot: _path.default.relative(_path.default.dirname(outputFilename), source),
      sourceFileName: _path.default.relative(source, filepath),
      filename: filepath,
      ...(babelrc || configFile ? null : {
        presets: [[require.resolve('@babel/preset-env'), {
          targets: _browserslist.default.findConfig(root) ?? {
            browsers: ['>1%', 'last 2 chrome versions', 'last 2 edge versions', 'last 2 firefox versions', 'last 2 safari versions', 'not dead', 'not ie <= 11', 'not op_mini all', 'not android <= 4.4', 'not samsung <= 4'],
            node: '18'
          },
          useBuiltIns: false,
          modules
        }], require.resolve('@babel/preset-react'), require.resolve('@babel/preset-typescript'), require.resolve('@babel/preset-flow')]
      })
    });
    if (result == null) {
      throw new Error('Output code was null');
    }
    let code = result.code;
    if (sourceMaps && result.map) {
      const mapFilename = outputFilename + '.map';
      code += '\n//# sourceMappingURL=' + _path.default.basename(mapFilename);

      // Don't inline the source code, it can be retrieved from the source file
      result.map.sourcesContent = undefined;
      await _fsExtra.default.writeJSON(mapFilename, result.map);
    }
    await _fsExtra.default.writeFile(outputFilename, code);
    if (copyFlow) {
      _fsExtra.default.copy(filepath, outputFilename + '.flow');
    }
  }));
  report.success(`Wrote files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
  const getGeneratedEntryPath = async () => {
    if (pkg.source) {
      const indexName = _path.default.basename(pkg.source).replace(/\.(jsx?|tsx?)$/, '') + '.js';
      const potentialPath = _path.default.join(output, _path.default.dirname(_path.default.relative(source, _path.default.join(root, pkg.source))), indexName);
      if (await _fsExtra.default.pathExists(potentialPath)) {
        return _path.default.relative(root, potentialPath);
      }
    }
    return null;
  };
  if (field in pkg) {
    try {
      require.resolve(_path.default.join(root, pkg[field]));
    } catch (e) {
      if (e != null && typeof e === 'object' && 'code' in e && e.code === 'MODULE_NOT_FOUND') {
        const generatedEntryPath = await getGeneratedEntryPath();
        if (!generatedEntryPath) {
          report.warn(`Failed to detect the entry point for the generated files. Make sure you have a valid ${_kleur.default.blue('source')} field in your ${_kleur.default.blue('package.json')}.`);
        }
        report.error(`The ${_kleur.default.blue(field)} field in ${_kleur.default.blue('package.json')} points to a non-existent file: ${_kleur.default.blue(pkg[field])}.\nVerify the path points to the correct file under ${_kleur.default.blue(_path.default.relative(root, output))}${generatedEntryPath ? ` (found ${_kleur.default.blue(generatedEntryPath)}).` : '.'}`);
        throw new Error(`Found incorrect path in '${field}' field.`);
      }
      throw e;
    }
  } else {
    const generatedEntryPath = await getGeneratedEntryPath();
    report.warn(`No ${_kleur.default.blue(field)} field found in ${_kleur.default.blue('package.json')}. Consider ${generatedEntryPath ? `pointing it to ${_kleur.default.blue(generatedEntryPath)}` : 'adding it'} so that consumers of your package can use it.`);
  }
}
//# sourceMappingURL=compile.js.map